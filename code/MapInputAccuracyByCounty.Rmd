---
title: "Calculate Accuracy of CDL and NVC rasters"
author: "Melanie Kammerer"
date: "1/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

## Objective
The goal of this script is to map the accuracy of CDL & NVC rasters. To do this, I use class-level data on spatial accuracy from USDA NASS and LANDFIRE for CDL and NVC, respectively. I combined accuracy statistics from two layers by calculating an area-weighted mean.

I start by loading accuracy data for EVT and NVC. We need NVC and EVT because NVC borrows some classes from EVT and LANDFIRE does not publish accuracy values for EVT classes in NVC data files. In this section I also create a list of LANDFIRE 'managed classes' (agriculture, burned, logged, etc). These classes were not included in reference database nor accuracy assessment so, when calculating data coverage, I exclude area covered in these classes.

```{r loadtabulardata, echo=F}
library(dplyr); library(logger); library(future); library(terra)
rm(list=ls())
# load accuracy data from LANDFIRE and USDA NASS (aggregated & formatted in 'AggregateAccuracyAssessmentData.Rmd' script)
evt <- read.csv('./data/LANDFIRE_Accuracy/EVT_Accuracy_allregions.csv')
nvc <- read.csv('./data/LANDFIRE_Accuracy/NVC_Accuracy_allregions.csv')

# accuracy assessment missing some classes (contingency tables sometimes only have classes with auto-key plots)

all_classes <- read.csv('./data/TabularData/LF_200NVC_05142020.csv')
toadd <- dplyr::filter(all_classes, !VALUE %in% nvc$LANDFIRE_Class) %>%
  dplyr::mutate(ProducerNPlots_autokey=0)

nvc <- dplyr::full_join(nvc, dplyr::select(toadd, VALUE, NVC_Name, ProducerNPlots_autokey), 
                        by=c('LANDFIRE_Class'='VALUE', 
                             'LANDFIRE_Name' ='NVC_Name','ProducerNPlots_autokey'))

length(unique(nvc$LANDFIRE_Class)) == length(unique(nvc$LANDFIRE_Name))
length(unique(nvc$LANDFIRE_Class)) == length(unique(all_classes$VALUE))


# custom max function that returns NA if both input values are NA
mymax <- function(...,def=NA,na.rm=FALSE) {
    if(!is.infinite(x<-suppressWarnings(max(...,na.rm=na.rm)))) {
      x } else {def}
}

# for NVC classes that were taken from EVT, use the accuracy data from EVT
lf <- dplyr::full_join(nvc, evt, by=c('LANDFIRE_Class','LANDFIRE_Name', 'Region'), suffix=c('.nvc', '.evt')) %>%
  dplyr::group_by(LANDFIRE_Class, LANDFIRE_Name, Region) %>%
  dplyr::mutate(ProducerAccuracy = mymax(ProducerAccuracy.nvc, ProducerAccuracy.evt, na.rm=T),
                ProducerNPlots_autokey = mymax(ProducerNPlots_autokey.nvc, ProducerNPlots_autokey.evt, na.rm=T),
                UserAccuracy = mymax(UserAccuracy.nvc, UserAccuracy.evt, na.rm=T),
                UserNPlots_map = mymax(UserNPlots_map.nvc, UserNPlots_map.evt, na.rm=T)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(LANDFIRE_NVC = paste(LANDFIRE_Class, LANDFIRE_Name))

#UserAccuracy = if_else(ProducerNPlots_autokey==ProducerNPlots_autokey.nvc, UserAccuracy.nvc, UserAccuracy.evt),
                #UserNPlots_map = if_else(ProducerNPlots_autokey==ProducerNPlots_autokey.nvc, UserNPlots_map.nvc, UserNPlots_map.evt)) %>%


# specify classes that COULD have plots in auto-key (are non-managed, not agriculture or NLCD developed)
nvc_agclasses <- c(7960:7999) # classes in LANDFIRE NVC that are agriculture

managed_classes <- lf$LANDFIRE_Class[grepl(lf$LANDFIRE_Name, pattern='Developed-') | 
                                       grepl(lf$LANDFIRE_Name, pattern='Recently Burned-') | 
                                       grepl(lf$LANDFIRE_Name, pattern='Recently Logged-') | 
                                       grepl(lf$LANDFIRE_Name, pattern='Recently Disturbed Other-') | 
                                       #grepl(lf$LANDFIRE_Name, pattern='Forest Plantation') | 
                                       lf$LANDFIRE_Class %in% nvc_agclasses |
                                         lf$LANDFIRE_Name == 'Open Water']
```
 
## Load NVC pixel frequency by county
Here, I load datasets generated by 'TabulatePixels3Rasters.R' script. All LANDFIRE accuracy assessments were conducted by region, so I also need to load a shapefile of the LF regions and label each county with the region it is contained within. Some counties cross regional boundaries, so I determine the appropriate region based on the centroid of each county polygons (some counties have multiple polygons due to non-contiguous land).
```{r loadfreq, echo=F}
library(dplyr)
# read county shapefile, remove polygons that are NA for county name (usually sections of water adjacent a state)
county_shp <- sf::st_read('D:/SpatialData/county_boundaries/us_counties_better_coasts.shp') %>%
  dplyr::filter(!is.na(COUNTY))

# add NVC region to county shapefile
# load region shapefile and reproject to match counties
regions <- sf::st_read('./data/SpatialData/LANDFIRE/us_lf_zones/us_lf_zones.shp') %>%
  dplyr::group_by(LF2010_GA) %>%
  summarize(geometry = sf::st_union(geometry)) %>% # original region shapefile had multiple polygons per region, so I dissolve them
  sf::st_transform(crs = sf::st_crs(county_shp)) # project region polygon to match counties

plot(regions)

# convert county polygons to centroids and calculate intersection between regions and county centroids
la <- sf::st_centroid(county_shp) %>% 
  sf::st_join(regions, join=sf::st_intersects) %>%
  dplyr::rename(LF2010_Region=LF2010_GA) %>%
  sf::st_drop_geometry() %>%
  dplyr::select(FIPS, LF2010_Region) %>%
  dplyr::arrange(FIPS)

# add region column to original county shapefile
county <- dplyr::arrange(county_shp, FIPS) %>% cbind(la) %>%
  dplyr::group_by(FIPS, STATE, COUNTY, STATE_FIPS, LF2010_Region) %>%
  summarize(geometry = sf::st_combine(geometry)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(!duplicated(paste0(STATE, COUNTY)))

plot(county[5])

#sf::st_write(county, './data/SpatialData/us_counties_better_coasts_LFregion.shp', append=F)

# read NVC pixel frequency data
nvc_county <- read.csv('./data/PixelFreq/NVC_CountyPixelFreq.csv') %>%
  dplyr::filter(!is.na(County)) %>%
  dplyr::group_by(State, County) %>%
  dplyr::mutate(PctCounty = NCells/sum(NCells)) %>%
  dplyr::ungroup() 

# are there any counties in county shapefile that are NOT in dataset on NVC pixel frequency?
paste0(county$COUNTY, ", ", county$STATE)[!paste0(county$COUNTY, ", ", county$STATE) %in% paste0(nvc_county$County, ", ", nvc_county$State)]

nvc_county <- sf::st_drop_geometry(county) %>%
    dplyr::select(STATE, COUNTY, LF2010_Region) %>%
    dplyr::left_join(nvc_county, by=c('STATE'='State', 'COUNTY'='County'))

# how many classes in spatial data are missing from tabular data?
sort(unique(nvc_county$Class[!nvc_county$Class %in% lf$LANDFIRE_Class]))

# filter tabular data to ONLY classes in spatial data
lf2 <- dplyr::filter(lf, LANDFIRE_Class %in% nvc_county$Class)

# write clean version of tabular data
write.csv(lf, './data/NVC_Accuracy_allregions_cleaned.csv', row.names=F)

```

# Join NVC accuracy metrics with pixel frequency
```{r join}
# join accuracy values to pixel frequency data
nvc_accuracy <- dplyr::left_join(nvc_county, lf, by=c('Class'='LANDFIRE_Class', 'LF2010_Region'='Region')) %>%
  dplyr::select(-contains('.evt') , -contains('.nvc'))

# why are there some counties with NA for NVC value?
nvc_accuracy[is.na(nvc_accuracy$Class),]

# make new variable of reference database status (well-represented, poorly-represented, absent, or managed/ag)
nvc_accuracy$RFDB_Status <- if_else(nvc_accuracy$Class %in% managed_classes, 'absent, managed/ag/disturbed', 
                            if_else((nvc_accuracy$ProducerNPlots_autokey == 0|is.na(nvc_accuracy$ProducerNPlots_autokey)) & 
                                 !nvc_accuracy$Class %in% managed_classes,  'absent, could be added', 
                            if_else(nvc_accuracy$ProducerNPlots_autokey >= 30, 'well-represented',
                            if_else(nvc_accuracy$ProducerNPlots_autokey < 30 & nvc_accuracy$ProducerNPlots_autokey > 0, 'poorly-represented',
                                  'uh oh'))))


# calculate total number of cells per county as well as accuracy*NCells of a specific class (will sum in next step to get area-weighted average)
nvc_accuracy <- dplyr::group_by(nvc_accuracy, STATE, COUNTY) %>%
  dplyr::mutate(NCells_County= sum(NCells), Weight_ProdAcc = NCells*ProducerAccuracy,
                Weight_UserAcc = NCells*UserAccuracy) %>%
  dplyr::group_by(STATE, COUNTY, NCells_County, RFDB_Status) 

# summarize ncell and accuracy by county and reference db status
# accuracy only applies to well-represented, but we will map data coverage of well and poorly represented classes
nvc_accuracy_bycounty <-  nvc_accuracy  %>% dplyr::summarize(NCells_Group = sum(NCells, na.rm=T), 
    Weight_ProdAcc = sum(Weight_ProdAcc, na.rm=T)/NCells_Group,
    Weight_UserAcc = sum(Weight_UserAcc, na.rm=T)/NCells_Group, .groups='keep') %>%
  dplyr::mutate(RFDB_Status2=RFDB_Status) %>%
  dplyr::ungroup()

# reshape ncells to wide format
ncells <- tidyr::pivot_wider(nvc_accuracy_bycounty, id_cols=c(STATE:COUNTY, NCells_County), names_from=RFDB_Status, 
                     values_from=NCells_Group) %>%
  tidyr::replace_na(list(`well-represented` = 0, `poorly-represented` = 0))
  
# reshape accuracy to wide format, filter to only well-represented classes
acc <- dplyr::filter(nvc_accuracy_bycounty, RFDB_Status == 'well-represented') %>% 
  tidyr::pivot_wider(id_cols=c(STATE:COUNTY, NCells_County), names_from=RFDB_Status, 
                     values_from=c(Weight_ProdAcc, Weight_UserAcc)) %>%
  dplyr::rename(WtdUserAcc = `Weight_UserAcc_well-represented`, WtdProdAcc = `Weight_ProdAcc_well-represented`)

# translate ncells to percentage of un-managed area in each county
toplot <- dplyr::mutate(ncells, NCells_Unmanaged = (NCells_County - `absent, managed/ag/disturbed`),
                        Rep_PctUnmanaged = (`well-represented` + `poorly-represented`)/NCells_Unmanaged,
                        WellRep_PctUnmanaged = (`well-represented`)/NCells_Unmanaged)
```

## Make maps of NVC data coverage and accuracy 
```{r mapnvc}
library(classInt); library(ggplot2); library(viridis)

# join results to spatial object for mapping
toplot_sf <- dplyr::left_join(county, toplot) %>%
  dplyr::left_join(acc)

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_sf, cols=c(Rep_PctUnmanaged, WellRep_PctUnmanaged), names_to='Type', values_to='DataCoverage') %>%
  ggplot(aes(x = DataCoverage)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Data coverage of NVC") +
  xlab("Area classes in RFDB / Area all un-managed classes") +
  scale_fill_discrete(name = "RFBD Status", labels=c('present (nplots > 0)', 'well-represented\n(nplots > 30)')) +
  scale_color_discrete(name = "RFBD Status", labels=c('present (nplots > 0)', 'well-represented\n(nplots > 30)'))


# maps of data coverage

natural.interval = BAMMtools::getJenksBreaks(toplot_sf$WellRep_PctUnmanaged, k = 7)
toplot_sf$population.natural.well = cut(toplot_sf$WellRep_PctUnmanaged, breaks=natural.interval, include.lowest = TRUE)

wellrep_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=population.natural.well)) +  
  guides(fill=guide_legend(title='Area in well-rep classes /\nArea unmanaged classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
wellrep_map_jenks

natural.interval = BAMMtools::getJenksBreaks(toplot_sf$Rep_PctUnmanaged, k = 7)
toplot_sf$population.natural = cut(toplot_sf$Rep_PctUnmanaged, breaks=natural.interval, include.lowest = TRUE)

rep_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=population.natural)) +  
  guides(fill=guide_legend(title='Area in rep classes /\nArea unmanaged classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
rep_map_jenks

# maps of NVC accuracy

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_sf, cols=c(WtdProdAcc, WtdUserAcc), names_to='Type', values_to='Accuracy') %>%
  ggplot(aes(x = Accuracy)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Accuracy of NVC")  +
  scale_fill_discrete(labels=c('Producer, area-wtd', 'User, area-wtd')) +
  scale_color_discrete(labels=c('Producer, area-wtd', 'User, area-wtd'))

# calculate jenk's breaks to use on map
natural.interval.pa <- BAMMtools::getJenksBreaks(toplot_sf$WtdProdAcc, k = 7)
toplot_sf$prodacc.natural = cut(toplot_sf$WtdProdAcc, breaks=natural.interval.pa, include.lowest = TRUE)

# map producer accuracy of NVC by county
prodacc_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=prodacc.natural)) +  
  guides(fill=guide_legend(title='Producer accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
prodacc_map_jenks

natural.interval.ua = BAMMtools::getJenksBreaks(toplot_sf$WtdUserAcc, k = 7)
toplot_sf$useracc.natural = cut(toplot_sf$WtdUserAcc, breaks=natural.interval.ua, include.lowest = TRUE)

# map user accuracy of NVC by county
useracc_map_jenks  <- ggplot() + geom_sf(data=toplot_sf, aes(fill=useracc.natural)) +  
  guides(fill=guide_legend(title='User accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
useracc_map_jenks 
```



```{r mapcdl}
names(county)
CDLYear <- 2016

cdl <- read.csv('./data/CDL_Accuracy/CDL_accuracy_long_allstates_2012to2020.csv')

# filter cdl to 2016 to match pixel freq data
cdl_oneyear <- dplyr::filter(cdl, Year %in% CDLYear)

cdl_freq <- read.csv(paste0('./data/PixelFreq/CDL', CDLYear, '_CountyPixelFreq.csv'))

head(cdl_freq)
head(cdl_oneyear)

cdl_accuracy <- dplyr::left_join(cdl_freq, cdl_oneyear,  by=c('Class'='CDL_Class', 'State')) %>%
  dplyr::mutate(GT_Status = if_else(is.na(Producer), "no ground-truth", "present")) %>%
  dplyr::group_by(Year, State, County) %>%
  dplyr::mutate(NCells_County = sum(NCells), Weight_ProdAcc = NCells*Producer,
                Weight_UserAcc = NCells*User) %>%
  dplyr::group_by(Year, State, County, NCells_County, GT_Status)

cdl_accuracy_bycounty <- cdl_accuracy %>% dplyr::summarize(NCells_Group = sum(NCells, na.rm=T), 
    Weight_ProdAcc = sum(Weight_ProdAcc, na.rm=T)/NCells_Group,
    Weight_UserAcc = sum(Weight_UserAcc, na.rm=T)/NCells_Group, .groups='keep') %>%
  dplyr::mutate(GT_Status2=GT_Status) %>%
  dplyr::ungroup()

# reshape ncells to wide format
ncells_cdl <- tidyr::pivot_wider(cdl_accuracy_bycounty, id_cols=c(Year:County, NCells_County), names_from=GT_Status, 
                     values_from=NCells_Group) %>%
  tidyr::replace_na(list(`present` = 0, `no ground-truth` = 0)) %>%
  dplyr::mutate(PresentGT_PctCounty = `present`/NCells_County)
  
# reshape accuracy to wide format, filter to only well-represented classes
acc_cdl <- dplyr::filter(cdl_accuracy_bycounty, GT_Status == 'present') %>% 
  tidyr::pivot_wider(id_cols=c(Year:County, NCells_County), names_from=GT_Status, 
                     values_from=c(Weight_ProdAcc, Weight_UserAcc)) %>%
  dplyr::rename(WtdUserAcc = `Weight_UserAcc_present`, WtdProdAcc = `Weight_ProdAcc_present`)

```
## Make maps of NVC data coverage and accuracy 
```{r maps_datacoverage}
# join results to spatial object for mapping
toplot_cdl <- dplyr::left_join(county, ncells_cdl, by=c('STATE'='State', 'COUNTY'='County')) %>%
  dplyr::left_join(acc_cdl)

# histograms of data coverage
hist(toplot_cdl$PresentGT_PctCounty, breaks=30)

# maps of data coverage
library(classInt); library(ggplot2); library(viridis)

natural.interval = BAMMtools::getJenksBreaks(toplot_cdl$PresentGT_PctCounty, k = 8)
toplot_cdl$population.natural.well = cut(toplot_cdl$PresentGT_PctCounty, breaks=natural.interval[2:length(natural.interval)], include.lowest = TRUE)

wellrep_map_jenks <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=population.natural.well)) +  
  guides(fill=guide_legend(title='Area in ground-truth classes\n/ Area all classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
wellrep_map_jenks

# maps of NVC accuracy

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_cdl, cols=c(WtdProdAcc, WtdUserAcc), names_to='Type', values_to='Accuracy') %>%
  ggplot(aes(x = Accuracy)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Accuracy of CDL 2016")

# calculate jenk's breaks to use on map
natural.interval.pa <- BAMMtools::getJenksBreaks(toplot_cdl$WtdProdAcc, k = 7)
toplot_cdl$prodacc.natural = cut(toplot_cdl$WtdProdAcc, breaks=natural.interval.pa, include.lowest = TRUE)

# map producer accuracy of NVC by county
prodacc_map_jenks <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=prodacc.natural)) +  
  guides(fill=guide_legend(title='Producer accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
prodacc_map_jenks

natural.interval.ua = BAMMtools::getJenksBreaks(toplot_cdl$WtdUserAcc, k = 7)
toplot_cdl$useracc.natural = cut(toplot_cdl$WtdUserAcc, breaks=natural.interval.ua, include.lowest = TRUE)

# map user accuracy of NVC by county
useracc_map_jenks  <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=useracc.natural)) +  
  guides(fill=guide_legend(title='User accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
useracc_map_jenks 
```




