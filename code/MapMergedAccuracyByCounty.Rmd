---
title: "Calculate Accuracy of Merged CDL/NVC Raster"
author: "Melanie Kammerer"
date: "1/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

## Objective
The goal of this script is to map the accuracy of CDL & NVC combined rasters. To do this, I use class-level data on spatial accuracy from USDA NASS and LANDFIRE for CDL and NVC, respectively. I combined accuracy statistics from two layers by calculating an area-weighted mean.

I start by loading accuracy data for EVT and NVC. We need NVC and EVT because NVC borrows some classes from EVT and LANDFIRE does not publish accuracy values for EVT classes in NVC data files. In this section I also create a list of LANDFIRE 'managed classes' (agriculture, burned, logged, etc). These classes were not included in reference database nor accuracy assessment so, when calculating data coverage, I exclude area covered in these classes.

```{r loadtabulardata, echo=F}
library(dplyr); library(logger); library(future); library(terra)
rm(list=ls())
CDLYear <- 2016


lf <- read.csv('./data/NVC_Accuracy_allregions_cleaned.csv')
```
 
## Load NVC pixel frequency by county
Here, I load datasets generated by 'TabulatePixels3Rasters.R' script. All LANDFIRE accuracy assessments were conducted by region, so I also need to load a shapefile of the LF regions and label each county with the region it is contained within. Some counties cross regional boundaries, so I determine the appropriate region based on the centroid of each county polygons (some counties have multiple polygons due to non-contiguous land).
```{r loadfreq, echo=F}
library(dplyr)
# read county shapefile with LANDFIRE regions
county <- sf::st_read('./data/SpatialData/us_counties_better_coasts_LFregion.shp') %>%
  dplyr::rename(LF2010_Region=LF2010_) # fix column name that was abbreviated by shp driver

# read NVC/CDL pixel frequency data
merged_freq <- read.csv(paste0('./data/PixelFreq/CDL', CDLYear, '_CountyPixelFreq.csv')) %>%
  dplyr::filter(!is.na(County)) %>%
  dplyr::group_by(State, County) %>%
  dplyr::mutate(PctCounty = NCells/sum(NCells)) %>%
  dplyr::ungroup() 

# are there any counties in county shapefile that are NOT in dataset on NVC pixel frequency?
paste0(county$COUNTY, ", ", county$STATE)[!paste0(county$COUNTY, ", ", county$STATE) %in% paste0(merged_freq$County, ", ", merged_freq$State)]

# join pixel frequency with LF regions
merged_freq <- sf::st_drop_geometry(county) %>%
    dplyr::select(STATE, COUNTY, LF2010_Region) %>%
    dplyr::left_join(merged_freq, by=c('STATE'='State', 'COUNTY'='County'))

```

## Join NVC accuracy metrics with pixel frequency
```{r joinnvc}
# join accuracy values to pixel frequency data
nvc_accuracy <- dplyr::left_join(merged_freq, lf, by=c('Class'='LANDFIRE_Class', 'LF2010_Region'='Region')) %>%
  dplyr::select(-contains('.evt') , -contains('.nvc'))

# why are there some counties with NA for NVC value?
nvc_accuracy[is.na(nvc_accuracy$Class),]

# make new variable of reference database status (well-represented, poorly-represented, absent, or managed/ag)
nvc_accuracy$RFDB_Status <- if_else(nvc_accuracy$Class %in% managed_classes, 'absent, managed/ag/disturbed', 
                            if_else((nvc_accuracy$ProducerNPlots_autokey == 0|is.na(nvc_accuracy$ProducerNPlots_autokey)) & 
                                 !nvc_accuracy$Class %in% managed_classes,  'absent, could be added', 
                            if_else(nvc_accuracy$ProducerNPlots_autokey >= 30, 'well-represented',
                            if_else(nvc_accuracy$ProducerNPlots_autokey < 30 & nvc_accuracy$ProducerNPlots_autokey > 0, 'poorly-represented',
                                  'not NVC'))))

```

## Join CDL accuracy metrics with pixel frequency
```{r joincdl}
cdl <- read.csv('./data/CDL_Accuracy/CDL_accuracy_long_allstates_2012to2020.csv')  %>%
  dplyr::mutate(GT_Status = if_else(is.na(Producer), "no ground-truth", "present")) %>%
  dplyr::rename(ProducerAccuracy=Producer, UserAccuracy=User)

# filter cdl to 2016 to match pixel freq data
cdl_oneyear <- dplyr::filter(cdl, Year %in% CDLYear)

#cdl_freq <- read.csv(paste0('./data/PixelFreq/CDL', CDLYear, '_CountyPixelFreq.csv'))

head(cdl_oneyear)
combined_accuracy <- dplyr::full_join(nvc_accuracy, cdl_oneyear,  by=c('Class'='CDL_Class', 
                                                                  'STATE'='State', 'ProducerAccuracy', 'UserAccuracy')) 
```


## Calculate area-weighted version of accuracy
```{r areaweight}
# calculate total number of cells per county as well as accuracy*NCells of a specific class (will sum in next step to get area-weighted average)
nvc_accuracy <- dplyr::group_by(nvc_accuracy, STATE, COUNTY) %>%
  dplyr::mutate(NCells_County= sum(NCells), Weight_ProdAcc = NCells*ProducerAccuracy,
                Weight_UserAcc = NCells*UserAccuracy) %>%
  dplyr::group_by(STATE, COUNTY, NCells_County, RFDB_Status) 

# summarize ncell and accuracy by county and reference db status
# accuracy only applies to well-represented, but we will map data coverage of well and poorly represented classes
nvc_accuracy_bycounty <-  nvc_accuracy  %>% dplyr::summarize(NCells_Group = sum(NCells, na.rm=T), 
    Weight_ProdAcc = sum(Weight_ProdAcc, na.rm=T)/NCells_Group,
    Weight_UserAcc = sum(Weight_UserAcc, na.rm=T)/NCells_Group, .groups='keep') %>%
  dplyr::mutate(RFDB_Status2=RFDB_Status) %>%
  dplyr::ungroup()

# reshape ncells to wide format
ncells <- tidyr::pivot_wider(nvc_accuracy_bycounty, id_cols=c(STATE:COUNTY, NCells_County), names_from=RFDB_Status, 
                     values_from=NCells_Group) %>%
  tidyr::replace_na(list(`well-represented` = 0, `poorly-represented` = 0))
  
# reshape accuracy to wide format, filter to only well-represented classes
acc <- dplyr::filter(nvc_accuracy_bycounty, RFDB_Status == 'well-represented') %>% 
  tidyr::pivot_wider(id_cols=c(STATE:COUNTY, NCells_County), names_from=RFDB_Status, 
                     values_from=c(Weight_ProdAcc, Weight_UserAcc)) %>%
  dplyr::rename(WtdUserAcc = `Weight_UserAcc_well-represented`, WtdProdAcc = `Weight_ProdAcc_well-represented`)

# translate ncells to percentage of un-managed area in each county
toplot <- dplyr::mutate(ncells, NCells_Unmanaged = (NCells_County - `absent, managed/ag/disturbed`),
                        Rep_PctUnmanaged = (`well-represented` + `poorly-represented`)/NCells_Unmanaged,
                        WellRep_PctUnmanaged = (`well-represented`)/NCells_Unmanaged)
```

## Make maps of NVC data coverage and accuracy 
```{r mapnvc}
library(classInt); library(ggplot2); library(viridis)

# join results to spatial object for mapping
toplot_sf <- dplyr::left_join(county, toplot) %>%
  dplyr::left_join(acc)

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_sf, cols=c(Rep_PctUnmanaged, WellRep_PctUnmanaged), names_to='Type', values_to='DataCoverage') %>%
  ggplot(aes(x = DataCoverage)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Data coverage of NVC") +
  xlab("Area classes in RFDB / Area all un-managed classes") +
  scale_fill_discrete(name = "RFBD Status", labels=c('present (nplots > 0)', 'well-represented\n(nplots > 30)')) +
  scale_color_discrete(name = "RFBD Status", labels=c('present (nplots > 0)', 'well-represented\n(nplots > 30)'))


# maps of data coverage

natural.interval = BAMMtools::getJenksBreaks(toplot_sf$WellRep_PctUnmanaged, k = 7)
toplot_sf$population.natural.well = cut(toplot_sf$WellRep_PctUnmanaged, breaks=natural.interval, include.lowest = TRUE)

wellrep_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=population.natural.well)) +  
  guides(fill=guide_legend(title='Area in well-rep classes /\nArea unmanaged classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
wellrep_map_jenks

natural.interval = BAMMtools::getJenksBreaks(toplot_sf$Rep_PctUnmanaged, k = 7)
toplot_sf$population.natural = cut(toplot_sf$Rep_PctUnmanaged, breaks=natural.interval, include.lowest = TRUE)

rep_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=population.natural)) +  
  guides(fill=guide_legend(title='Area in rep classes /\nArea unmanaged classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
rep_map_jenks

# maps of NVC accuracy

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_sf, cols=c(WtdProdAcc, WtdUserAcc), names_to='Type', values_to='Accuracy') %>%
  ggplot(aes(x = Accuracy)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Accuracy of NVC")  +
  scale_fill_discrete(labels=c('Producer, area-wtd', 'User, area-wtd')) +
  scale_color_discrete(labels=c('Producer, area-wtd', 'User, area-wtd'))

# calculate jenk's breaks to use on map
natural.interval.pa <- BAMMtools::getJenksBreaks(toplot_sf$WtdProdAcc, k = 7)
toplot_sf$prodacc.natural = cut(toplot_sf$WtdProdAcc, breaks=natural.interval.pa, include.lowest = TRUE)

# map producer accuracy of NVC by county
prodacc_map_jenks <- ggplot() + geom_sf(data=toplot_sf, aes(fill=prodacc.natural)) +  
  guides(fill=guide_legend(title='Producer accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
prodacc_map_jenks

natural.interval.ua = BAMMtools::getJenksBreaks(toplot_sf$WtdUserAcc, k = 7)
toplot_sf$useracc.natural = cut(toplot_sf$WtdUserAcc, breaks=natural.interval.ua, include.lowest = TRUE)

# map user accuracy of NVC by county
useracc_map_jenks  <- ggplot() + geom_sf(data=toplot_sf, aes(fill=useracc.natural)) +  
  guides(fill=guide_legend(title='User accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
useracc_map_jenks 
```



```{r mapcdl}
names(county)
CDLYear <- 2016

cdl <- read.csv('./data/CDL_Accuracy/CDL_accuracy_long_allstates_2012to2020.csv')

# filter cdl to 2016 to match pixel freq data
cdl_oneyear <- dplyr::filter(cdl, Year %in% CDLYear)

cdl_freq <- read.csv(paste0('./data/PixelFreq/CDL', CDLYear, '_CountyPixelFreq.csv'))

head(cdl_freq)
head(cdl_oneyear)

cdl_accuracy <- dplyr::left_join(cdl_freq, cdl_oneyear,  by=c('Class'='CDL_Class', 'State')) %>%
  dplyr::mutate(GT_Status = if_else(is.na(Producer), "no ground-truth", "present")) %>%
  dplyr::group_by(Year, State, County) %>%
  dplyr::mutate(NCells_County = sum(NCells), Weight_ProdAcc = NCells*Producer,
                Weight_UserAcc = NCells*User) %>%
  dplyr::group_by(Year, State, County, NCells_County, GT_Status)

cdl_accuracy_bycounty <- cdl_accuracy %>% dplyr::summarize(NCells_Group = sum(NCells, na.rm=T), 
    Weight_ProdAcc = sum(Weight_ProdAcc, na.rm=T)/NCells_Group,
    Weight_UserAcc = sum(Weight_UserAcc, na.rm=T)/NCells_Group, .groups='keep') %>%
  dplyr::mutate(GT_Status2=GT_Status) %>%
  dplyr::ungroup()

# reshape ncells to wide format
ncells_cdl <- tidyr::pivot_wider(cdl_accuracy_bycounty, id_cols=c(Year:County, NCells_County), names_from=GT_Status, 
                     values_from=NCells_Group) %>%
  tidyr::replace_na(list(`present` = 0, `no ground-truth` = 0)) %>%
  dplyr::mutate(PresentGT_PctCounty = `present`/NCells_County)
  
# reshape accuracy to wide format, filter to only well-represented classes
acc_cdl <- dplyr::filter(cdl_accuracy_bycounty, GT_Status == 'present') %>% 
  tidyr::pivot_wider(id_cols=c(Year:County, NCells_County), names_from=GT_Status, 
                     values_from=c(Weight_ProdAcc, Weight_UserAcc)) %>%
  dplyr::rename(WtdUserAcc = `Weight_UserAcc_present`, WtdProdAcc = `Weight_ProdAcc_present`)

```
## Make maps of NVC data coverage and accuracy 
```{r maps_datacoverage}
# join results to spatial object for mapping
toplot_cdl <- dplyr::left_join(county, ncells_cdl, by=c('STATE'='State', 'COUNTY'='County')) %>%
  dplyr::left_join(acc_cdl)

# histograms of data coverage
hist(toplot_cdl$PresentGT_PctCounty, breaks=30)

# maps of data coverage
library(classInt); library(ggplot2); library(viridis)

natural.interval = BAMMtools::getJenksBreaks(toplot_cdl$PresentGT_PctCounty, k = 8)
toplot_cdl$population.natural.well = cut(toplot_cdl$PresentGT_PctCounty, breaks=natural.interval[2:length(natural.interval)], include.lowest = TRUE)

wellrep_map_jenks <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=population.natural.well)) +  
  guides(fill=guide_legend(title='Area in ground-truth classes\n/ Area all classes')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
wellrep_map_jenks

# maps of NVC accuracy

# histogram of accuracy by county (user and producer)
tidyr::pivot_longer(toplot_cdl, cols=c(WtdProdAcc, WtdUserAcc), names_to='Type', values_to='Accuracy') %>%
  ggplot(aes(x = Accuracy)) + 
  geom_histogram(aes(y=..density.., col=Type) ,
                 fill = "white") +
  geom_density(lwd = 1, aes(colour = Type, fill = Type), alpha = 0.25) +
  theme_classic(base_size=14) +
  ggtitle("Accuracy of CDL 2016")

# calculate jenk's breaks to use on map
natural.interval.pa <- BAMMtools::getJenksBreaks(toplot_cdl$WtdProdAcc, k = 7)
toplot_cdl$prodacc.natural = cut(toplot_cdl$WtdProdAcc, breaks=natural.interval.pa, include.lowest = TRUE)

# map producer accuracy of NVC by county
prodacc_map_jenks <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=prodacc.natural)) +  
  guides(fill=guide_legend(title='Producer accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
prodacc_map_jenks

natural.interval.ua = BAMMtools::getJenksBreaks(toplot_cdl$WtdUserAcc, k = 7)
toplot_cdl$useracc.natural = cut(toplot_cdl$WtdUserAcc, breaks=natural.interval.ua, include.lowest = TRUE)

# map user accuracy of NVC by county
useracc_map_jenks  <- ggplot() + geom_sf(data=toplot_cdl, aes(fill=useracc.natural)) +  
  guides(fill=guide_legend(title='User accuracy \n(area-weighted)')) +
  theme_classic() + 
  scale_fill_viridis(discrete=T)
useracc_map_jenks 
```




